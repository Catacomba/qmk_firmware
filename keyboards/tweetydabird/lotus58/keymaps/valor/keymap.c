#include QMK_KEYBOARD_H
#include "quantum\keymap_extras\keymap_slovenian.h"
/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
	
 * This file was later edited by me (Valor, Catacomba, Kevin)! 
 
 */

enum unicode_names {
	SI_SCARON_LOWER,
	SI_SCARON_UPPER,
	SI_ZCARON_LOWER,
    SI_ZCARON_UPPER,
    SI_CCARON_LOWER,
    SI_CCARON_UPPER,
};

const uint32_t unicode_map[] PROGMEM = {
	// Unicode codes for each character
	// š/Š
	[SI_SCARON_LOWER] = 0x0161,
	[SI_SCARON_UPPER] = 0x0160,
	// ž/Ž
	[SI_ZCARON_LOWER] = 0x017E,
	[SI_ZCARON_UPPER] = 0x017D,
	// č/Č
	[SI_CCARON_LOWER] = 0x010D,
	[SI_CCARON_UPPER] = 0x010C,
};

uint8_t current_os = 0; // 0 = Linux, 1 = Windows, 2 = macOS

enum layers {
    _BASE = 0,
	_LAYER1 = 1,
	_LAYER2 = 2,
	_RGB = 3,
};

enum OS {
    _LINUX = 0,
	_WINDOWS = 1,
};

#define SI_SCARON XP(SI_SCARON_LOWER, SI_SCARON_UPPER)
#define SI_ZCARON XP(SI_ZCARON_LOWER, SI_ZCARON_UPPER)
#define SI_CCARON XP(SI_CCARON_LOWER, SI_CCARON_UPPER)

enum custom_keycodes {
    SWITCH_OS = SAFE_RANGE,
    PRINT_OS
};        

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[_BASE] = LAYOUT(
     // XXXXXXX , XXXXXXX , XXXXXXX   , XXXXXXX   , XXXXXXX , XXXXXXX   , XXXXXXX , XXXXXXX       , XXXXXXX   , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX .
    	KC_ESC  , KC_1    , KC_2      , KC_3      , KC_4    , KC_5      ,                           KC_6      , KC_7    , KC_8    , KC_9    , KC_0    , KC_EQL  , 
    	KC_TAB  , KC_Q    , KC_W      , KC_E      , KC_R    , KC_T      ,                           KC_Z      , KC_U    , KC_I    , KC_O    , KC_P    , KC_SLSH , 
    	KC_LSFT , KC_A    , KC_S      , KC_D      , KC_F    , KC_G      ,                           KC_H      , KC_J    , KC_K    , KC_L    , KC_SCLN , KC_QUOT , 
    	KC_LCTL , KC_Y    , KC_X      , KC_C      , KC_V    , KC_B      , KC_LBRC , KC_AUDIO_MUTE , KC_N      , KC_M    , KC_COMM , KC_DOT  , KC_MINS , KC_BSLS , 
		                                KC_LALT   , KC_LGUI ,MO(_LAYER1), KC_SPC  , KC_ENT        , MO(_LAYER2), KC_BSPC , KC_RALT
       ),
    [_LAYER1] = LAYOUT(
     // XXXXXXX , XXXXXXX , XXXXXXX   , XXXXXXX   , XXXXXXX , XXXXXXX   , XXXXXXX , XXXXXXX , XXXXXXX   , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX .
    	KC_GRV  , KC_F1   , KC_F2     , KC_F3     , KC_F4   , KC_F5     ,                     KC_F6     , KC_F7   , KC_F8   , KC_F9   , KC_F10  , XXXXXXX , 
    	_______ , KC_F11  , KC_F12    , XXXXXXX   ,S(KC_LBRC),S(KC_RBRC),                     SI_ZCARON , KC_RALT , KC_ROPT , KC_ALGR , KC_RIGHT_ALT , KC_PAST , 
    	_______ , KC_Q    , SI_SCARON , XXXXXXX   , KC_LBRC , KC_RBRC   ,                     RGB_MOD , RGB_SPI , RGB_HUI , RGB_SAI , RGB_VAI , XXXXXXX , 
    	_______ , XXXXXXX , XXXXXXX   , SI_CCARON , S(KC_9) , S(KC_0)   , XXXXXXX , XXXXXXX , RGB_RMOD, RGB_SPD , RGB_HUD , RGB_SAD , RGB_VAD , KC_PPLS , 
                                        KC_RALT   , _______ , _______   , _______ , _______ , MO(_RGB), KC_DELETE , _______
    ),
    [_LAYER2] = LAYOUT(	
     // XXXXXXX , XXXXXXX , XXXXXXX   , XXXXXXX   , XXXXXXX , XXXXXXX   , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX .
    	_______ , XXXXXXX , XXXXXXX   , XXXXXXX   , XXXXXXX , XXXXXXX   ,                     XXXXXXX , XXXXXXX , KC_PGUP , XXXXXXX , XXXXXXX , XXXXXXX ,
    	_______ , KC_BTN1 , KC_MS_U   , KC_BTN2   , XXXXXXX , XXXXXXX   ,                     XXXXXXX , KC_HOME , KC_UP   , KC_END  , XXXXXXX , XXXXXXX , 
    	_______ , KC_MS_L , KC_MS_D   , KC_MS_R   , XXXXXXX , XXXXXXX   ,                     XXXXXXX , KC_LEFT , KC_DOWN , KC_RGHT , XXXXXXX , XXXXXXX , 
    	_______ , XXXXXXX , XXXXXXX   , XXXXXXX   , KC_V    , XXXXXXX   , XXXXXXX , XXXXXXX , XXXXXXX , KC_BTN4 , KC_PGDN , KC_BTN5 , XXXXXXX , XXXXXXX , 
    	                                KC_RALT   , _______ , MO(_RGB)  , _______ , _______ , _______ , _______ , _______
    ),
    [_RGB] = LAYOUT(
     // XXXXXXX     , XXXXXXX         , XXXXXXX           , XXXXXXX        , XXXXXXX , XXXXXXX   , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX .
    	KC_KB_POWER , KC_SYSTEM_POWER , KC_SYSTEM_SLEEP   , KC_SYSTEM_WAKE , XXXXXXX , XXXXXXX   ,                     XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX ,  
    	SWITCH_OS   , XXXXXXX         , XXXXXXX           , XXXXXXX        , XXXXXXX , XXXXXXX   ,                     XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , RGB_MODE_PLAIN , 
    	PRINT_OS    , XXXXXXX         , XXXXXXX           , XXXXXXX        , XXXXXXX , XXXXXXX   ,                     XXXXXXX , RGB_MOD , RGB_SPI , RGB_HUI , RGB_SAI , RGB_VAI , 
    	XXXXXXX     , XXXXXXX         , XXXXXXX           , XXXXXXX        , XXXXXXX , XXXXXXX   , XXXXXXX , XXXXXXX , XXXXXXX , RGB_RMOD, RGB_SPD , RGB_HUD , RGB_SAD , RGB_VAD , 
    	                                                    _______        , _______ , _______   , _______ , _______ , _______ , _______ , _______
	)
};

#if defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][2] = {
    [_BASE] =    { ENCODER_CCW_CW(KC_MS_WH_UP, KC_MS_WH_DOWN), ENCODER_CCW_CW(KC_VOLU, KC_VOLD)  },
    [_LAYER1] =  { ENCODER_CCW_CW(RGB_HUD,     RGB_HUI),       ENCODER_CCW_CW(KC_UP,    KC_DOWN)  },
    [_LAYER2] =  { ENCODER_CCW_CW(KC_LEFT,     KC_RIGHT),      ENCODER_CCW_CW(RGB_SPD,  RGB_SPI)  },
    [_RGB] =     { ENCODER_CCW_CW(RGB_RMOD,    RGB_MOD),       ENCODER_CCW_CW(KC_RIGHT, KC_LEFT)  },
};
#endif // defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case PRINT_OS:
            // This is to test which mode i am in
            if (record->event.pressed) {
                if (current_os == _LINUX) {
                    SEND_STRING("Linux");
					return false;
                } else if (current_os == _WINDOWS) {
                    SEND_STRING("Windows");
					return false;
                }
            }
            break;
        // The following three cases work on windows and linux, I am leaving as is for now, so that i can still switch between the two modes if it turns out
        // that it doesnt work well on windows for whatever reason.
        // TODO in future: if it turns out that two modes are not needed, remove the OS setting checks
        case SI_ZCARON:
            if (record->event.pressed) {
                if (current_os == _LINUX) {
                    // Linux: Compose + z + <
                    // == ž (capitalization automatically works)
                    SEND_STRING(SS_TAP(X_RALT) SS_TAP(X_Z) SS_LSFT(SS_TAP(X_COMMA)));
					return false;
                }
            }
            break;
        case SI_SCARON:
            if (record->event.pressed) {
                if (current_os == _LINUX) {
                    // Linux: Compose + s + <
                    // == š (capitalization automatically works)
                    SEND_STRING(SS_TAP(X_RALT) SS_TAP(X_S) SS_LSFT(SS_TAP(X_COMMA)));
					return false;
                }
            }
            break;
        case SI_CCARON:
            if (record->event.pressed) {
                if (current_os == _LINUX) {
                    // Linux: Compose + c + <
                    // == č (capitalization automatically works)
                    SEND_STRING(SS_TAP(X_RALT) SS_TAP(X_C) SS_LSFT(SS_TAP(X_COMMA)));
					return false;
                }
            }
            break;
        case SWITCH_OS:
            if (record->event.pressed) {
                // Cycle through OS modes (0 → 1 → 0)
                current_os = (current_os + 1) % 2;
            }
            break;
    }
    return true;
};
